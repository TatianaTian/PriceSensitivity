{"ast":null,"code":"var _slicedToArray = require(\"@babel/runtime/helpers/slicedToArray\");\n\nfunction _createForOfIteratorHelper(o) { if (typeof Symbol === \"undefined\" || o[Symbol.iterator] == null) { if (Array.isArray(o) || (o = _unsupportedIterableToArray(o))) { var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var it, normalCompletion = true, didErr = false, err; return { s: function s() { it = o[Symbol.iterator](); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(n); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nvar jsregression = require('js-regression');\n\nvar linear_regression = function linear_regression(sales, exchange_rate) {\n  var _reformat_data = reformat_data(sales, exchange_rate),\n      _reformat_data2 = _slicedToArray(_reformat_data, 2),\n      data = _reformat_data2[0],\n      myMap = _reformat_data2[1];\n\n  console.log(\"data is \", data);\n  var regression = new jsregression.LinearRegression();\n  console.log(\"here\");\n  var model = regression.fit(data);\n  var myMap2 = new Map();\n  myMap2 = myMap; // sort exchange rate\n\n  exchange_rate.sort(function (a, b) {\n    return a - b;\n  });\n  var regression_fx = [];\n  var regression_sales = [];\n  var regression_predicted_sales = [];\n\n  for (j = 0; j < exchange_rate.length; j++) {\n    regression_fx.push(exchange_rate[j]);\n    regression_sales.push(myMap2.get(exchange_rate[j])); //console.log(\"[exchange_rate[i]] is \", exchange_rate[j])\n\n    regression_predicted_sales.push(regression.transform([exchange_rate[j]]));\n  }\n\n  return [regression_fx, regression_sales, regression_predicted_sales];\n};\n\nfunction reformat_data(sales, exchange_rate) {\n  var data = [];\n  var myMap = new Map();\n\n  for (i = 0; i < exchange_rate.length; i++) {\n    var round_fx = Math.round(1000 * exchange_rate[i]) / 1000;\n\n    if (myMap.has(round_fx)) {\n      var sales_list = myMap.get(round_fx);\n      sales_list.push(sales[i]);\n      myMap.set(round_fx, sales_list);\n    }\n\n    myMap.set(round_fx, [sales[i]]);\n  }\n\n  var _iterator = _createForOfIteratorHelper(myMap),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var _step$value = _slicedToArray(_step.value, 2),\n          k = _step$value[0],\n          v = _step$value[1];\n\n      var sum = v.reduce(function (previous, current) {\n        return current += previous;\n      });\n      var avg = sum / v.length;\n      data.push([k, avg]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return [data, myMap];\n}\n\nmodule.exports = linear_regression; //linear_regression([20,50,60],[4,9,7])\n\n/*\nvar data = [];\ndata = [[1,2],[2,3],[3,4]]\n \n// === Create the linear regression === //\nvar regression = new jsregression.LinearRegression();\n// can also use default configuration: var regression = new jsregression.LinearRegression(); \n \n// === Train the linear regression === //\nvar model = regression.fit(data);\n \n// === Print the trained model === //\nconsole.log(model);\nconsole.log(regression.transform([3]));\n \n /*\n// === Testing the trained linear regression === //\nvar testingData = [];\nfor(var x = 1.0; x < 100.0; x += 1.0) {\n  var actual_y = 2.0 + 5.0 * x + 2.0 * x * x + Math.random() * 1.0;\n  var predicted_y = regression.transform([x, x * x]);\n  console.log(\"actual: \" + actual_y + \" predicted: \" + predicted_y); \n}*/","map":{"version":3,"sources":["/Users/tatianatian/Desktop/Startup/shopify_front_back_end/client/functions/linear_regression.js"],"names":["jsregression","require","linear_regression","sales","exchange_rate","reformat_data","data","myMap","console","log","regression","LinearRegression","model","fit","myMap2","Map","sort","a","b","regression_fx","regression_sales","regression_predicted_sales","j","length","push","get","transform","i","round_fx","Math","round","has","sales_list","set","k","v","sum","reduce","previous","current","avg","module","exports"],"mappings":"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","sourcesContent":["var jsregression = require('js-regression');\n\nconst linear_regression = (sales, exchange_rate)=>{\n    var [data, myMap] = reformat_data(sales, exchange_rate)\n    console.log(\"data is \", data)\n    var regression = new jsregression.LinearRegression();\n    console.log(\"here\")\n    var model = regression.fit(data);\n    \n    let myMap2 = new Map();\n    myMap2 = myMap\n\n    // sort exchange rate\n    exchange_rate.sort(function(a, b){return a-b});\n    var regression_fx = []\n    var regression_sales = []\n    var regression_predicted_sales = []\n    \n    for (j=0;j<exchange_rate.length;j++){\n        regression_fx.push(exchange_rate[j])\n        regression_sales.push(myMap2.get(exchange_rate[j]))\n        //console.log(\"[exchange_rate[i]] is \", exchange_rate[j])\n        regression_predicted_sales.push(regression.transform([exchange_rate[j]]))\n    }\n    return [regression_fx, regression_sales, regression_predicted_sales]\n}\n\nfunction reformat_data(sales, exchange_rate){\n    const data = []\n    let myMap = new Map()\n    for (i=0;i<exchange_rate.length;i++){\n        var round_fx = Math.round(1000*exchange_rate[i])/1000;\n        if (myMap.has(round_fx)){\n            var sales_list = myMap.get(round_fx)\n            sales_list.push(sales[i])\n            myMap.set(round_fx,sales_list)\n        }\n        myMap.set(round_fx,[sales[i]])\n    }\n    for (let [k, v] of myMap) {\n        let sum = v.reduce((previous, current) => current += previous);\n        let avg = sum / v.length;\n        data.push([k, avg])\n    }\n\n    return [data, myMap]\n}\n \nmodule.exports = linear_regression; \n\n//linear_regression([20,50,60],[4,9,7])\n\n/*\nvar data = [];\ndata = [[1,2],[2,3],[3,4]]\n \n// === Create the linear regression === //\nvar regression = new jsregression.LinearRegression();\n// can also use default configuration: var regression = new jsregression.LinearRegression(); \n \n// === Train the linear regression === //\nvar model = regression.fit(data);\n \n// === Print the trained model === //\nconsole.log(model);\nconsole.log(regression.transform([3]));\n \n /*\n// === Testing the trained linear regression === //\nvar testingData = [];\nfor(var x = 1.0; x < 100.0; x += 1.0) {\n  var actual_y = 2.0 + 5.0 * x + 2.0 * x * x + Math.random() * 1.0;\n  var predicted_y = regression.transform([x, x * x]);\n  console.log(\"actual: \" + actual_y + \" predicted: \" + predicted_y); \n}*/\n"]},"metadata":{},"sourceType":"script"}